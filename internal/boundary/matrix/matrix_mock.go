// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package matrix

import (
	"github.com/Markus-Schwer/ordaa/internal/entity"
	"gorm.io/gorm"
	"maunium.net/go/mautrix/event"
	"maunium.net/go/mautrix/id"
	"sync"
)

// Ensure, that MatrixBoundaryMock does implement MatrixBoundary.
// If this is not the case, regenerate this file with moq.
var _ MatrixBoundary = &MatrixBoundaryMock{}

// MatrixBoundaryMock is a mock implementation of MatrixBoundary.
//
//	func TestSomethingThatUsesMatrixBoundary(t *testing.T) {
//
//		// make and configure a mocked MatrixBoundary
//		mockedMatrixBoundary := &MatrixBoundaryMock{
//			StartFunc: func()  {
//				panic("mock out the Start method")
//			},
//			getUserByUsernameFunc: func(tx *gorm.DB, username string) (*entity.User, error) {
//				panic("mock out the getUserByUsername method")
//			},
//			handleMessageEventFunc: func(evt *event.Event)  {
//				panic("mock out the handleMessageEvent method")
//			},
//			listenFunc: func()  {
//				panic("mock out the listen method")
//			},
//			loginAndJoinFunc: func(roomIds []string)  {
//				panic("mock out the loginAndJoin method")
//			},
//			messageFunc: func(room id.RoomID, content string)  {
//				panic("mock out the message method")
//			},
//			reactFunc: func(room id.RoomID, evt id.EventID, content string)  {
//				panic("mock out the react method")
//			},
//			replyFunc: func(room id.RoomID, evt id.EventID, content string, asHtml bool) id.EventID {
//				panic("mock out the reply method")
//			},
//		}
//
//		// use mockedMatrixBoundary in code that requires MatrixBoundary
//		// and then make assertions.
//
//	}
type MatrixBoundaryMock struct {
	// StartFunc mocks the Start method.
	StartFunc func()

	// getUserByUsernameFunc mocks the getUserByUsername method.
	getUserByUsernameFunc func(tx *gorm.DB, username string) (*entity.User, error)

	// handleMessageEventFunc mocks the handleMessageEvent method.
	handleMessageEventFunc func(evt *event.Event)

	// listenFunc mocks the listen method.
	listenFunc func()

	// loginAndJoinFunc mocks the loginAndJoin method.
	loginAndJoinFunc func(roomIds []string)

	// messageFunc mocks the message method.
	messageFunc func(room id.RoomID, content string)

	// reactFunc mocks the react method.
	reactFunc func(room id.RoomID, evt id.EventID, content string)

	// replyFunc mocks the reply method.
	replyFunc func(room id.RoomID, evt id.EventID, content string, asHtml bool) id.EventID

	// calls tracks calls to the methods.
	calls struct {
		// Start holds details about calls to the Start method.
		Start []struct {
		}
		// getUserByUsername holds details about calls to the getUserByUsername method.
		getUserByUsername []struct {
			// Tx is the tx argument value.
			Tx *gorm.DB
			// Username is the username argument value.
			Username string
		}
		// handleMessageEvent holds details about calls to the handleMessageEvent method.
		handleMessageEvent []struct {
			// Evt is the evt argument value.
			Evt *event.Event
		}
		// listen holds details about calls to the listen method.
		listen []struct {
		}
		// loginAndJoin holds details about calls to the loginAndJoin method.
		loginAndJoin []struct {
			// RoomIds is the roomIds argument value.
			RoomIds []string
		}
		// message holds details about calls to the message method.
		message []struct {
			// Room is the room argument value.
			Room id.RoomID
			// Content is the content argument value.
			Content string
		}
		// react holds details about calls to the react method.
		react []struct {
			// Room is the room argument value.
			Room id.RoomID
			// Evt is the evt argument value.
			Evt id.EventID
			// Content is the content argument value.
			Content string
		}
		// reply holds details about calls to the reply method.
		reply []struct {
			// Room is the room argument value.
			Room id.RoomID
			// Evt is the evt argument value.
			Evt id.EventID
			// Content is the content argument value.
			Content string
			// AsHtml is the asHtml argument value.
			AsHtml bool
		}
	}
	lockStart              sync.RWMutex
	lockgetUserByUsername  sync.RWMutex
	lockhandleMessageEvent sync.RWMutex
	locklisten             sync.RWMutex
	lockloginAndJoin       sync.RWMutex
	lockmessage            sync.RWMutex
	lockreact              sync.RWMutex
	lockreply              sync.RWMutex
}

// Start calls StartFunc.
func (mock *MatrixBoundaryMock) Start() {
	if mock.StartFunc == nil {
		panic("MatrixBoundaryMock.StartFunc: method is nil but MatrixBoundary.Start was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStart.Lock()
	mock.calls.Start = append(mock.calls.Start, callInfo)
	mock.lockStart.Unlock()
	mock.StartFunc()
}

// StartCalls gets all the calls that were made to Start.
// Check the length with:
//
//	len(mockedMatrixBoundary.StartCalls())
func (mock *MatrixBoundaryMock) StartCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStart.RLock()
	calls = mock.calls.Start
	mock.lockStart.RUnlock()
	return calls
}

// getUserByUsername calls getUserByUsernameFunc.
func (mock *MatrixBoundaryMock) getUserByUsername(tx *gorm.DB, username string) (*entity.User, error) {
	if mock.getUserByUsernameFunc == nil {
		panic("MatrixBoundaryMock.getUserByUsernameFunc: method is nil but MatrixBoundary.getUserByUsername was just called")
	}
	callInfo := struct {
		Tx       *gorm.DB
		Username string
	}{
		Tx:       tx,
		Username: username,
	}
	mock.lockgetUserByUsername.Lock()
	mock.calls.getUserByUsername = append(mock.calls.getUserByUsername, callInfo)
	mock.lockgetUserByUsername.Unlock()
	return mock.getUserByUsernameFunc(tx, username)
}

// getUserByUsernameCalls gets all the calls that were made to getUserByUsername.
// Check the length with:
//
//	len(mockedMatrixBoundary.getUserByUsernameCalls())
func (mock *MatrixBoundaryMock) getUserByUsernameCalls() []struct {
	Tx       *gorm.DB
	Username string
} {
	var calls []struct {
		Tx       *gorm.DB
		Username string
	}
	mock.lockgetUserByUsername.RLock()
	calls = mock.calls.getUserByUsername
	mock.lockgetUserByUsername.RUnlock()
	return calls
}

// handleMessageEvent calls handleMessageEventFunc.
func (mock *MatrixBoundaryMock) handleMessageEvent(evt *event.Event) {
	if mock.handleMessageEventFunc == nil {
		panic("MatrixBoundaryMock.handleMessageEventFunc: method is nil but MatrixBoundary.handleMessageEvent was just called")
	}
	callInfo := struct {
		Evt *event.Event
	}{
		Evt: evt,
	}
	mock.lockhandleMessageEvent.Lock()
	mock.calls.handleMessageEvent = append(mock.calls.handleMessageEvent, callInfo)
	mock.lockhandleMessageEvent.Unlock()
	mock.handleMessageEventFunc(evt)
}

// handleMessageEventCalls gets all the calls that were made to handleMessageEvent.
// Check the length with:
//
//	len(mockedMatrixBoundary.handleMessageEventCalls())
func (mock *MatrixBoundaryMock) handleMessageEventCalls() []struct {
	Evt *event.Event
} {
	var calls []struct {
		Evt *event.Event
	}
	mock.lockhandleMessageEvent.RLock()
	calls = mock.calls.handleMessageEvent
	mock.lockhandleMessageEvent.RUnlock()
	return calls
}

// listen calls listenFunc.
func (mock *MatrixBoundaryMock) listen() {
	if mock.listenFunc == nil {
		panic("MatrixBoundaryMock.listenFunc: method is nil but MatrixBoundary.listen was just called")
	}
	callInfo := struct {
	}{}
	mock.locklisten.Lock()
	mock.calls.listen = append(mock.calls.listen, callInfo)
	mock.locklisten.Unlock()
	mock.listenFunc()
}

// listenCalls gets all the calls that were made to listen.
// Check the length with:
//
//	len(mockedMatrixBoundary.listenCalls())
func (mock *MatrixBoundaryMock) listenCalls() []struct {
} {
	var calls []struct {
	}
	mock.locklisten.RLock()
	calls = mock.calls.listen
	mock.locklisten.RUnlock()
	return calls
}

// loginAndJoin calls loginAndJoinFunc.
func (mock *MatrixBoundaryMock) loginAndJoin(roomIds []string) {
	if mock.loginAndJoinFunc == nil {
		panic("MatrixBoundaryMock.loginAndJoinFunc: method is nil but MatrixBoundary.loginAndJoin was just called")
	}
	callInfo := struct {
		RoomIds []string
	}{
		RoomIds: roomIds,
	}
	mock.lockloginAndJoin.Lock()
	mock.calls.loginAndJoin = append(mock.calls.loginAndJoin, callInfo)
	mock.lockloginAndJoin.Unlock()
	mock.loginAndJoinFunc(roomIds)
}

// loginAndJoinCalls gets all the calls that were made to loginAndJoin.
// Check the length with:
//
//	len(mockedMatrixBoundary.loginAndJoinCalls())
func (mock *MatrixBoundaryMock) loginAndJoinCalls() []struct {
	RoomIds []string
} {
	var calls []struct {
		RoomIds []string
	}
	mock.lockloginAndJoin.RLock()
	calls = mock.calls.loginAndJoin
	mock.lockloginAndJoin.RUnlock()
	return calls
}

// message calls messageFunc.
func (mock *MatrixBoundaryMock) message(room id.RoomID, content string) {
	if mock.messageFunc == nil {
		panic("MatrixBoundaryMock.messageFunc: method is nil but MatrixBoundary.message was just called")
	}
	callInfo := struct {
		Room    id.RoomID
		Content string
	}{
		Room:    room,
		Content: content,
	}
	mock.lockmessage.Lock()
	mock.calls.message = append(mock.calls.message, callInfo)
	mock.lockmessage.Unlock()
	mock.messageFunc(room, content)
}

// messageCalls gets all the calls that were made to message.
// Check the length with:
//
//	len(mockedMatrixBoundary.messageCalls())
func (mock *MatrixBoundaryMock) messageCalls() []struct {
	Room    id.RoomID
	Content string
} {
	var calls []struct {
		Room    id.RoomID
		Content string
	}
	mock.lockmessage.RLock()
	calls = mock.calls.message
	mock.lockmessage.RUnlock()
	return calls
}

// react calls reactFunc.
func (mock *MatrixBoundaryMock) react(room id.RoomID, evt id.EventID, content string) {
	if mock.reactFunc == nil {
		panic("MatrixBoundaryMock.reactFunc: method is nil but MatrixBoundary.react was just called")
	}
	callInfo := struct {
		Room    id.RoomID
		Evt     id.EventID
		Content string
	}{
		Room:    room,
		Evt:     evt,
		Content: content,
	}
	mock.lockreact.Lock()
	mock.calls.react = append(mock.calls.react, callInfo)
	mock.lockreact.Unlock()
	mock.reactFunc(room, evt, content)
}

// reactCalls gets all the calls that were made to react.
// Check the length with:
//
//	len(mockedMatrixBoundary.reactCalls())
func (mock *MatrixBoundaryMock) reactCalls() []struct {
	Room    id.RoomID
	Evt     id.EventID
	Content string
} {
	var calls []struct {
		Room    id.RoomID
		Evt     id.EventID
		Content string
	}
	mock.lockreact.RLock()
	calls = mock.calls.react
	mock.lockreact.RUnlock()
	return calls
}

// reply calls replyFunc.
func (mock *MatrixBoundaryMock) reply(room id.RoomID, evt id.EventID, content string, asHtml bool) id.EventID {
	if mock.replyFunc == nil {
		panic("MatrixBoundaryMock.replyFunc: method is nil but MatrixBoundary.reply was just called")
	}
	callInfo := struct {
		Room    id.RoomID
		Evt     id.EventID
		Content string
		AsHtml  bool
	}{
		Room:    room,
		Evt:     evt,
		Content: content,
		AsHtml:  asHtml,
	}
	mock.lockreply.Lock()
	mock.calls.reply = append(mock.calls.reply, callInfo)
	mock.lockreply.Unlock()
	return mock.replyFunc(room, evt, content, asHtml)
}

// replyCalls gets all the calls that were made to reply.
// Check the length with:
//
//	len(mockedMatrixBoundary.replyCalls())
func (mock *MatrixBoundaryMock) replyCalls() []struct {
	Room    id.RoomID
	Evt     id.EventID
	Content string
	AsHtml  bool
} {
	var calls []struct {
		Room    id.RoomID
		Evt     id.EventID
		Content string
		AsHtml  bool
	}
	mock.lockreply.RLock()
	calls = mock.calls.reply
	mock.lockreply.RUnlock()
	return calls
}
