package frontend

import (
	"strings"
	"errors"
	"fmt"
	"net/http"
	"github.com/rs/zerolog/log"
	"github.com/gorilla/mux"
	"github.com/gofrs/uuid"
	"time"
	"gitlab.com/sfz.aalen/hackwerk/dotinder/entity"
	"github.com/golang-jwt/jwt/v5"
)

type OrderWithItems struct {
	Uuid          string
	Initiator     *entity.User
	SugarPerson   *entity.User
	State         string
	OrderDeadline string
	Eta           string
	Menu          *entity.MenuWithItems
	GroupedItems  []*GroupedItem
}

type GroupedItem struct {
	User  *entity.User
	Price int
	Items []*OrderItem
}

type OrderItem struct {
	Uuid     string
	User     *entity.User
	MenuItem *entity.MenuItem
	Price    int
	Paid     bool
}

func (server *FrontendBoundary) getOrder(w http.ResponseWriter, r *http.Request) {
	token, ok := server.authService.CheckAuthCookie(r)
	if !ok {
		order(nil, nil, errors.New("unauthorized")).Render(r.Context(), w)
		return
	}

	uuid_string := mux.Vars(r)["uuid"]
	orderUuid, err := uuid.FromString(uuid_string)
	if err != nil {
		order(nil, token, err).Render(server.ctx, w)
		return
	}

	tx := server.repo.Pool.MustBegin()
	dbOrder, err := server.repo.GetOrder(tx, orderUuid)
	if err != nil {
		order(nil, token, err).Render(server.ctx, w)
		return
	}

	users, err := server.repo.GetAllUsers(tx)
	if err != nil {
		order(nil, token, err).Render(server.ctx, w)
		return
	}

	userMap := make(map[uuid.UUID]*entity.User)
	for i := range users {
		userMap[users[i].Uuid] = &users[i]
	}

	initiator := userMap[dbOrder.Initiator]

	var sugarPerson *entity.User
	if dbOrder.SugarPerson != nil {
		sugarPerson = userMap[*dbOrder.SugarPerson]
	}

	menu, err := server.repo.GetMenu(tx, dbOrder.MenuUuid)
	if err != nil {
		order(nil, token, err).Render(server.ctx, w)
		return
	}
	menuItemsMap := make(map[uuid.UUID]*entity.MenuItem)
	for i := range menu.Items {
		menuItemsMap[menu.Items[i].Uuid] = &menu.Items[i]
	}

	var orderDeadline, eta string
	if dbOrder.OrderDeadline != nil {
		orderDeadline = dbOrder.OrderDeadline.Format(time.TimeOnly)
	}
	if dbOrder.Eta != nil {
		eta = dbOrder.Eta.Format(time.TimeOnly)
	}

	if r.ContentLength != 0 {
		shortName := strings.Split(r.FormValue("menu_item"), ":")[0]
		if shortName == "" {
			order(nil, token, errors.New("short name is empty")).Render(server.ctx, w)
			return
		}

		var menuItem *entity.MenuItem
		for _, item := range menu.Items {
			if item.ShortName == shortName {
				menuItem = &item
				log.Ctx(server.ctx).Info().Msgf("found menu item %s", item.Uuid)
				log.Ctx(server.ctx).Info().Msgf("found menu item in map %s", menuItemsMap[item.Uuid].Uuid)
				break
			}
		}

		username, err := token.Claims.GetSubject()
		if err != nil {
			order(nil, token, fmt.Errorf("get username from token %w", err)).Render(server.ctx, w)
		}

		log.Ctx(server.ctx).Info().Msgf("user id %s", username)
		pwUser, err := server.repo.FindPasswordUser(tx, username)
		if err != nil {
			order(nil, token, fmt.Errorf("could not find pw user %w", err)).Render(server.ctx, w)
			return
		}

		createdOrderItem, err := server.repo.CreateOrderItem(tx, orderUuid, entity.NewOrderItem{MenuItemUuid: menuItem.Uuid, User: pwUser.UserUuid, Price: menuItem.Price})
		if err != nil {
			order(nil, token, fmt.Errorf("could not create order item %w", err)).Render(server.ctx, w)
			return
		}
		err = tx.Commit()
		if err != nil {
			order(nil, token, fmt.Errorf("could not commit transaction %w", err)).Render(server.ctx, w)
			return
		}
		dbOrder.Items = append(dbOrder.Items, *createdOrderItem)
	}

	groupedItems := map[uuid.UUID]*GroupedItem{}
	for _, orderItem := range dbOrder.Items {
		item := &OrderItem{
			Uuid:     orderItem.Uuid.String(),
			User:     userMap[orderItem.User],
			MenuItem: menuItemsMap[orderItem.MenuItemUuid],
			Price:    orderItem.Price,
			Paid:     orderItem.Paid,
		}

		existingGroupItem, ok := groupedItems[orderItem.User]
		if !ok {
			groupedItems[orderItem.User] = &GroupedItem{
				User:  userMap[orderItem.User],
				Price: item.Price,
				Items: []*OrderItem{item},
			}
		} else {
			existingGroupItem.Items = append(existingGroupItem.Items, item)
			existingGroupItem.Price += item.MenuItem.Price
		}
	}

	groupedItemsArray := []*GroupedItem{}
	for _, groupedItem := range groupedItems {
		groupedItemsArray = append(groupedItemsArray, groupedItem)
	}

	order(&OrderWithItems{
		Uuid:          dbOrder.Uuid.String(),
		Initiator:     initiator,
		SugarPerson:   sugarPerson,
		State:         dbOrder.State,
		OrderDeadline: orderDeadline,
		Eta:           eta,
		Menu:          menu,
		GroupedItems:  groupedItemsArray,
	}, token, nil).Render(r.Context(), w)
}

templ order(order *OrderWithItems, token *jwt.Token, err error) {
	@layout("Menü", err, token) {
		<div class="container my-5">
			<nav aria-label="breadcrumb">
				<ol class="breadcrumb">
					<li class="breadcrumb-item"><a href="/orders">Bestellungen</a></li>
					<li class="breadcrumb-item active" aria-current="page">{ order.Menu.Name }</li>
				</ol>
			</nav>
			<h2>Order: { order.Menu.Name }</h2>
			<dl class="row">
				<dt class="col-sm-2">Menu:</dt>
				<dd class="col-sm-10">{ order.Menu.Name }</dd>
				<dt class="col-sm-2">Status:</dt>
				<dd class="col-sm-10">{ order.State }</dd>
				<dt class="col-sm-2">Bestellschluss:</dt>
				<dd class="col-sm-10">19:00 Uhr</dd>
				<dt class="col-sm-2">Gestartet von:</dt>
				<dd class="col-sm-10">{ order.Initiator.Name }</dd>
			</dl>
			<hr></hr>
			<form action={ templ.SafeURL(fmt.Sprintf("/orders/%s", order.Uuid)) } method="POST">
				<div class="mb-5">
					<label for="menuDataList" class="form-label">Menü bestellen</label>
					<div class="input-group">
						<input class="form-control" list="datalistOptions" id="menuDataList" name="menu_item" aria-describedby="add-order-addon"></input>
						<datalist id="datalistOptions">
							for _, item := range order.Menu.Items {
								<option value={ fmt.Sprintf("%s: %s", item.ShortName, item.Name) }></option>
							}
						</datalist>
						<button type="submit" class="btn btn-primary" id="add-order-addon">+</button>
					</div>
				</div>
			</form>
			<div class="table-responsive" id="#orders-table">
				<table class="table table-hover">
					<thead>
						<tr>
							<th scope="col">Abkürzung</th>
							<th scope="col">Name</th>
							<th scope="col" class="text-end">Preis</th>
						</tr>
					</thead>
					<tbody>
						for _, groupedItem := range order.GroupedItems {
							<tr class="table-group-divider">
								<th scope="row" colspan="2">{ groupedItem.User.Name }</th>
								<td class="text-end"><strong>{ fmt.Sprintf("%d,%2d€", groupedItem.Price/100, groupedItem.Price%100) }</strong></td>
							</tr>
							for _, orderItem := range groupedItem.Items {
								<tr>
									<tbody>
										<tr>
											<th scope="row">{ orderItem.MenuItem.ShortName }</th>
											<td>{ orderItem.MenuItem.Name }</td>
											<td colspan="2" class="text-end">{ fmt.Sprintf("%d,%2d€", orderItem.MenuItem.Price/100, orderItem.MenuItem.Price%100) }</td>
										</tr>
									</tbody>
								</tr>
							}
						}
					</tbody>
				</table>
			</div>
		</div>
	}
}
