package frontend

import (
	"fmt"
	"net/http"
	"github.com/rs/zerolog/log"
	"github.com/go-pkgz/auth/token"
	"github.com/gorilla/mux"
	"github.com/gofrs/uuid"
	"time"
	"gitlab.com/sfz.aalen/hackwerk/dotinder/entity"
)

type OrderWithItems struct {
	Uuid          string
	Initiator     *entity.User
	SugarPerson   *entity.User
	State         string
	OrderDeadline string
	Eta           string
	Menu          *entity.MenuWithItems
	GroupedItems  []*GroupedItem
}

type GroupedItem struct {
	User  *entity.User
	Price int
	Items []*OrderItem
}

type OrderItem struct {
	Uuid     string
	User     *entity.User
	MenuItem *entity.MenuItem
	Price    int
	Paid     bool
}

func (server *FrontendBoundary) getOrder(w http.ResponseWriter, r *http.Request) {
	user, err := token.GetUserInfo(r);
	if err != nil {
		log.Ctx(server.ctx).Error().Err(err).Msg("failed to get user info")
		menus(nil, nil, err).Render(r.Context(), w)
		return
	}

	uuid_string := mux.Vars(r)["uuid"]
	orderUuid, err := uuid.FromString(uuid_string)
	if err != nil {
		order(nil, &user, err).Render(server.ctx, w)
		return
	}

	tx := server.repo.Pool.MustBegin()
	dbOrder, err := server.repo.GetOrder(tx, orderUuid)
	if err != nil {
		order(nil, &user, err).Render(server.ctx, w)
		return
	}

	users, err := server.repo.GetAllUsers(tx)
	if err != nil {
		order(nil, &user, err).Render(server.ctx, w)
		return
	}

	userMap := make(map[uuid.UUID]*entity.User)
	for _, user := range users {
		userMap[user.Uuid] = &user
	}

	initiator := userMap[dbOrder.Initiator]

	var sugarPerson *entity.User
	if dbOrder.SugarPerson != nil {
		sugarPerson = userMap[*dbOrder.SugarPerson]
	}

	menu, err := server.repo.GetMenu(tx, dbOrder.MenuUuid)
	if err != nil {
		order(nil, &user, err).Render(server.ctx, w)
		return
	}
	menuItemsMap := make(map[uuid.UUID]*entity.MenuItem)
	for _, menuItem := range menu.Items {
		menuItemsMap[menuItem.Uuid] = &menuItem
	}

	var orderDeadline, eta string
	if dbOrder.OrderDeadline != nil {
		orderDeadline = dbOrder.OrderDeadline.Format(time.TimeOnly)
	}
	if dbOrder.Eta != nil {
		eta = dbOrder.Eta.Format(time.TimeOnly)
	}

	groupedItems := map[uuid.UUID]*GroupedItem{}
	for _, orderItem := range dbOrder.Items {
		item := &OrderItem{
			Uuid:     orderItem.Uuid.String(),
			User:     userMap[orderItem.User],
			MenuItem: menuItemsMap[orderItem.MenuItemUuid],
			Price:    orderItem.Price,
			Paid:     orderItem.Paid,
		}

		existingGroupItem, ok := groupedItems[orderItem.User]
		if !ok {
			groupedItems[orderItem.User] = &GroupedItem{
				User:  userMap[orderItem.User],
				Price: item.Price,
				Items: []*OrderItem{item},
			}
		} else {
			existingGroupItem.Items = append(existingGroupItem.Items, item)
			existingGroupItem.Price += item.MenuItem.Price
		}

	}

	groupedItemsArray := []*GroupedItem{}
	for _, groupedItem := range groupedItems {
		groupedItemsArray = append(groupedItemsArray, groupedItem)
	}

	order(&OrderWithItems{
		Uuid:          dbOrder.Uuid.String(),
		Initiator:     initiator,
		SugarPerson:   sugarPerson,
		State:         dbOrder.State,
		OrderDeadline: orderDeadline,
		Eta:           eta,
		Menu:          menu,
		GroupedItems:  groupedItemsArray,
	}, &user, nil).Render(r.Context(), w)
}

templ order(order *OrderWithItems, user *token.User, err error) {
	@layout("Menü", err, user) {
		<div class="container my-5">
			<h2>Order: { order.Menu.Name }</h2>
			<dl class="row">
				<dt class="col-sm-2">Menu:</dt>
				<dd class="col-sm-10">{ order.Menu.Name }</dd>
				<dt class="col-sm-2">Status:</dt>
				<dd class="col-sm-10">{ order.State }</dd>
				<dt class="col-sm-2">Bestellschluss:</dt>
				<dd class="col-sm-10">19:00 Uhr</dd>
				<dt class="col-sm-2">Gestartet von:</dt>
				<dd class="col-sm-10">{ order.Initiator.Name }</dd>
			</dl>
			<div class="table-responsive">
				<table class="table table-hover">
					<thead>
						<tr>
							<th scope="col">Abkürzung</th>
							<th scope="col">Name</th>
							<th scope="col" class="text-end">Preis</th>
						</tr>
					</thead>
					<tbody>
						for _, groupedItem := range order.GroupedItems {
							<tr class="table-group-divider">
								<td>{ groupedItem.User.Name }</td>
								<th scope="row" colspan="4">{ groupedItem.User.Name }</th>
								<td>{ fmt.Sprintf("%d,%2d€", groupedItem.Price/100, groupedItem.Price%100) }</td>
							</tr>
							for _, orderItem := range groupedItem.Items {
								<tr>
									<tbody>
										<tr>
											<th scope="row" colspan="2">{ orderItem.MenuItem.ShortName }</th>
											<td>{ orderItem.MenuItem.Name }</td>
											<td colspan="2">{ fmt.Sprintf("%d,%2d€", orderItem.MenuItem.Price/100, orderItem.MenuItem.Price%100) }</td>
										</tr>
									</tbody>
								</tr>
							}
						}
					</tbody>
				</table>
			</div>
		</div>
	}
}
